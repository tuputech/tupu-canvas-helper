{"version":3,"sources":["heatmap/config.js","heatmap/canvas2d.js","heatmap/renderer.js","heatmap/data.js","heatmap/core.js","index.js","node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["HeatmapConfig","defaultRadius","defaultRenderer","defaultGradient","defaultMaxOpacity","defaultMinOpacity","defaultBlur","defaultXField","defaultYField","defaultValueField","plugins","container","canvas","backgroundColor","width","height","useGradientOpacity","Canvas2dRenderer","_getColorPalette","config","gradientConfig","gradient","paletteCanvas","document","createElement","paletteCtx","getContext","createLinearGradient","key","addColorStop","data","fillStyle","fillRect","getImageData","_getPointTemplate","radius","blurFactor","tplCanvas","tplCtx","x","y","beginPath","arc","Math","PI","fill","createRadialGradient","_prepareData","obj","xValuesLen","min","max","radi","renderData","xValues","Object","keys","length","yValuesLen","xValue","yValues","yValue","value","push","shadowCanvas","_renderBoundaries","computed","getComputedStyle","className","_width","replace","_height","shadowCtx","ctx","style","cssText","position","appendChild","_palette","_templates","_setStyles","prototype","renderPartial","_drawAlpha","_colorize","renderAll","_clear","_updateGradient","updateConfig","setDimensions","clearRect","_blur","blur","_opacity","opacity","_maxOpacity","maxOpacity","_minOpacity","minOpacity","_useGradientOpacity","dataLen","_min","_max","point","rectX","rectY","tpl","templateAlpha","globalAlpha","drawImage","maxWidth","maxHeight","img","imgData","len","palette","i","alpha","offset","finalAlpha","putImageData","getValueAt","abs","getDataURL","toDataURL","getCanvas","Renderer","Store","_coordinator","_data","_total","_radi","_xField","_yField","_valueField","_cfgRadius","_organiseData","dataPoint","forceRender","store","storedVal","setDataMax","setDataMin","_unOrganizeData","unorganizedData","_onExtremaChange","emit","addData","arguments","dataArr","call","organisedEntry","getExtremaData","total","setData","dataPoints","pointsLen","_getInternalData","setCoordinator","coordinator","getData","heatmapFactory","Coordinator","cStore","on","evtName","callback","scope","_connect","renderer","_renderer","_store","_config","onExtremaChange","Heatmap","assign","pluginToLoad","Error","plugin","apply","removeData","configure","repaint","getGradient","create","register","pluginKey","drawImageScaled","layers","layer","options","canvasWidth","offsetWidth","canvasHeight","offsetHeight","actualSize","ratio","hRatio","vRatio","fixedWidth","fixedHeight","map","la","index","drawGradient","gradientCfg","extrema","type","padding","paddingR","paddingB","graW","graH","fontSize","bgW","bgH","x0","y0","x1","y1","font","textBottom","unit","fix","minValue","middleValue","maxValue","text","toFixed","item","fillText","getImageInfo","path","Promise","resolve","reject","Image","onload","onerror","e","src","drawHeatmap","points","directionPoints","accuracy","then","heatmapInstance","heatmap","gradientCanvas","directionCanvas","drawDirection","filtration","drawText","centerPoint","fontFamily","color","usePercent","border","w","clientWidth","h","clientHeight","getAbsPoint","measureText","drawTextBorder","textWidth","textAlign","textBaseLineCenterPoint","paddingL","paddingT","Array","isArray","rectWidth","rectHeight","leftTopPoint","drawRoundRect","lineWidth","lineColor","drawRect","drawPolygon","l","startPoint","moveTo","p","lineTo","strokeStyle","stroke","strokeRect","getPointsTotalAndMax","maxDirectionValue","isPointArray","canvasArrow","fromx","fromy","tox","toy","canvasGradient","headlen","angle","atan2","cos","sin","minImgLength","maxLinelength","round","direction","label","count","lineLength","pow2","pow","lengthXY","getExtremeValueForTrack","tracks","maxCount","minCount","canvasArrowForTrack","maxLineWidth","getTrackCanvas","diff","linePoint","walkPoints","drawTrack","checkedAssets","assetsToAccept","OVERLAY_ID","OldModule","module","bundle","Module","moduleName","hot","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","dispose","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","handled","assets","forEach","asset","isNew","hmrAcceptCheck","global","parcelRequire","id","every","generated","js","console","clear","hmrApply","v","hmrAcceptRun","window","reload","close","onclose","log","removeErrorOverlay","error","message","stack","overlay","createErrorOverlay","body","getElementById","remove","stackTrace","innerText","innerHTML","getParents","modules","parents","k","d","dep","concat","Function","deps","cached","cache","some","cb"],"mappings":"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","file":"tupu-canvas-helper.min.js","sourceRoot":"..","sourcesContent":["'use strict'\n\nconst HeatmapConfig = {\n    // 默认半径: radius\n    defaultRadius: 40,\n    // 渲染主体: 目前只有dom端。只实现了canvas2d, 其他还可以自己渲染\n    // todo: 小程序, node端\n    defaultRenderer: 'canvas2d',\n    // 渐变的梯度, 定义热力红点\n    defaultGradient: {\n        0.25: 'rgb(0,0,255)',\n        0.55: 'rgb(0,255,0)',\n        0.85: 'rgb(255,255,0)',\n        1.0: 'rgb(255,0,0)',\n    },\n    // 透明度\n    defaultMaxOpacity: 1,\n    defaultMinOpacity: 0,\n\n    // 模糊设定\n    defaultBlur: 0.85,\n\n    // 坐标的x轴\n    defaultXField: 'x',\n    // 坐标的y轴\n    defaultYField: 'y',\n    // 坐标的权重key值\n    defaultValueField: 'value',\n    // 热力图的插件\n    plugins: {},\n\n    // 代码用到的\n\n    // canvas使用到的容器。\n    // 不传container直接传canvas也是可以的\n    container: null,\n    // canvas主体\n    canvas: null,\n    // canvas backgroundColor\n    backgroundColor: '',\n    // canvas的长宽, 不用带px。\n    // 不传默认取container的长宽\n    width: '',\n    height: '',\n    // 是否使用渐变透明度\n    useGradientOpacity: false,\n}\n\nexport default HeatmapConfig\n","const _getColorPalette = function(config) {\n    const gradientConfig = config.gradient || config.defaultGradient\n    const paletteCanvas = document.createElement('canvas')\n    const paletteCtx = paletteCanvas.getContext('2d')\n\n    paletteCanvas.width = 256\n    paletteCanvas.height = 1\n\n    // 创建canvas渐变对象\n    // params(x0,y0,x1,y1)\n    // 开始点坐标(x0,y0), 结束点坐标(x1, y1)\n    const gradient = paletteCtx.createLinearGradient(0, 0, 256, 1)\n    for (let key in gradientConfig) {\n        gradient.addColorStop(key, gradientConfig[key])\n    }\n\n    paletteCtx.fillStyle = gradient\n    // params(x,y,width,height)\n    // x: 矩形左上角的x坐标\n    // y: 矩形左上角的y坐标\n    paletteCtx.fillRect(0, 0, 256, 1)\n\n    // 返回ImageData 对象，该对象拷贝了画布指定矩形的像素数据。\n    const { data } = paletteCtx.getImageData(0, 0, 256, 1)\n    return data\n}\n\nconst _getPointTemplate = function(radius, blurFactor) {\n    const tplCanvas = document.createElement('canvas')\n    const tplCtx = tplCanvas.getContext('2d')\n    const x = radius\n    const y = radius\n    tplCanvas.width = tplCanvas.height = radius * 2\n\n    if (blurFactor === 1) {\n        tplCtx.beginPath()\n        tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false)\n        tplCtx.fillStyle = 'rgba(0,0,0,1)'\n        tplCtx.fill()\n    } else {\n        // 里黑外白\n        const gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius)\n        gradient.addColorStop(0, 'rgba(0,0,0,1)')\n        gradient.addColorStop(1, 'rgba(0,0,0,0)')\n        tplCtx.fillStyle = gradient\n        tplCtx.fillRect(0, 0, 2 * radius, 2 * radius)\n    }\n\n    return tplCanvas\n}\n\nconst _prepareData = function(obj) {\n    const { min, max, radi, data } = obj\n    const renderData = []\n\n    const xValues = Object.keys(data)\n    let xValuesLen = xValues.length\n\n    while (xValuesLen--) {\n        const xValue = xValues[xValuesLen]\n        const yValues = Object.keys(data[xValue])\n        let yValuesLen = yValues.length\n        while (yValuesLen--) {\n            const yValue = yValues[yValuesLen]\n            const value = data[xValue][yValue]\n            const radius = radi[xValue][yValue]\n            renderData.push({\n                x: xValue,\n                y: yValue,\n                value: value,\n                radius: radius,\n            })\n        }\n    }\n\n    return {\n        min,\n        max,\n        data: renderData,\n    }\n}\n\nfunction Canvas2dRenderer(config) {\n    const container = config.container\n    // shadowCanvas外面不能配置?\n    const shadowCanvas = (this.shadowCanvas = document.createElement('canvas'))\n    const canvas = (this.canvas = config.canvas || document.createElement('canvas'))\n    // 原点的边界\n    this._renderBoundaries = [10000, 10000, 0, 0]\n\n    // 浏览器api, 获取容器的真实长宽。再set给shadowCanvas和canvas\n    // eslint-disable-next-line no-undef\n    const computed = config.container ? getComputedStyle(config.container) : {}\n\n    canvas.className = 'heatmap-canvas'\n\n    this._width = canvas.width = shadowCanvas.width =\n        config.width || +computed.width.replace(/px/, '')\n    this._height = canvas.height = shadowCanvas.height =\n        config.height || +computed.height.replace(/px/, '')\n\n    this.shadowCtx = shadowCanvas.getContext('2d')\n    this.ctx = canvas.getContext('2d')\n\n    // @TODO:\n    // conditional wrapper\n    canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;'\n\n    if (container) {\n        container.style.position = 'relative'\n        container.appendChild(canvas)\n    }\n\n    // init 调色板;\n    // 返回 ImageData.data\n    this._palette = _getColorPalette(config)\n    this._templates = {}\n\n    // inin Styles\n    this._setStyles(config)\n}\n\nCanvas2dRenderer.prototype = {\n    renderPartial: function(data) {\n        if (data.data.length > 0) {\n            this._drawAlpha(data)\n            this._colorize()\n        }\n    },\n    renderAll: function(data) {\n        // reset render boundaries\n        this._clear()\n        if (Object.keys(data.data).length > 0) {\n            this._drawAlpha(_prepareData(data))\n            this._colorize()\n        }\n    },\n    _updateGradient: function(config) {\n        this._palette = _getColorPalette(config)\n    },\n    updateConfig: function(config) {\n        if (config['gradient']) {\n            this._updateGradient(config)\n        }\n        this._setStyles(config)\n    },\n    setDimensions: function(width, height) {\n        this._width = width\n        this._height = height\n        this.canvas.width = this.shadowCanvas.width = width\n        this.canvas.height = this.shadowCanvas.height = height\n    },\n    _clear: function() {\n        this.shadowCtx.clearRect(0, 0, this._width, this._height)\n        this.ctx.clearRect(0, 0, this._width, this._height)\n    },\n    _setStyles: function(config) {\n        this._blur = config.blur === 0 ? 0 : config.blur || config.defaultBlur\n\n        if (config.backgroundColor) {\n            this.canvas.style.backgroundColor = config.backgroundColor\n        }\n\n        this._width = this.canvas.width = this.shadowCanvas.width = config.width || this._width\n        this._height = this.canvas.height = this.shadowCanvas.height = config.height || this._height\n\n        this._opacity = (config.opacity || 0) * 255\n        this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255\n        this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255\n        this._useGradientOpacity = !!config.useGradientOpacity\n    },\n    _drawAlpha: function(obj) {\n        const min = (this._min = obj.min)\n        const max = (this._max = obj.max)\n        const data = obj.data || []\n        let dataLen = data.length\n        // on a point basis?\n        const blur = 1 - this._blur\n\n        while (dataLen--) {\n            const point = data[dataLen]\n\n            const x = point.x\n            const y = point.y\n            const radius = point.radius\n            // if value is bigger than max\n            // use max as value\n            const value = Math.min(point.value, max)\n            const rectX = x - radius\n            const rectY = y - radius\n            const shadowCtx = this.shadowCtx\n\n            let tpl\n            if (!this._templates[radius]) {\n                this._templates[radius] = tpl = _getPointTemplate(radius, blur)\n            } else {\n                tpl = this._templates[radius]\n            }\n            // value from minimum / value range\n            // => [0, 1]\n            const templateAlpha = max - min === 0 ? 1 : (value - min) / (max - min)\n            // this fixes #176: small values are not visible because globalAlpha < .01 cannot be read from imageData\n            shadowCtx.globalAlpha = templateAlpha < 0.01 ? 0.01 : templateAlpha\n\n            // 左上角画一张图, 黑白色\n            shadowCtx.drawImage(tpl, rectX, rectY)\n\n            // update renderBoundaries\n            if (rectX < this._renderBoundaries[0]) {\n                this._renderBoundaries[0] = rectX\n            }\n            if (rectY < this._renderBoundaries[1]) {\n                this._renderBoundaries[1] = rectY\n            }\n            if (rectX + 2 * radius > this._renderBoundaries[2]) {\n                this._renderBoundaries[2] = rectX + 2 * radius\n            }\n            if (rectY + 2 * radius > this._renderBoundaries[3]) {\n                this._renderBoundaries[3] = rectY + 2 * radius\n            }\n        }\n    },\n    _colorize: function() {\n        let x = this._renderBoundaries[0]\n        let y = this._renderBoundaries[1]\n        let width = this._renderBoundaries[2] - x\n        let height = this._renderBoundaries[3] - y\n        const maxWidth = this._width\n        const maxHeight = this._height\n        const opacity = this._opacity\n        const maxOpacity = this._maxOpacity\n        const minOpacity = this._minOpacity\n        const useGradientOpacity = this._useGradientOpacity\n\n        if (x < 0) {\n            x = 0\n        }\n        if (y < 0) {\n            y = 0\n        }\n        if (x + width > maxWidth) {\n            width = maxWidth - x\n        }\n        if (y + height > maxHeight) {\n            height = maxHeight - y\n        }\n\n        let img = this.shadowCtx.getImageData(x, y, width, height)\n        const imgData = img.data\n        const len = imgData.length\n        const palette = this._palette\n\n        for (let i = 3; i < len; i += 4) {\n            // alpha代表透明度。数值越打代表越 range(0, 255)\n\n            // palette.length = 256 * 1 * 4\n            const alpha = imgData[i]\n            const offset = alpha * 4\n\n            if (!offset) {\n                continue\n            }\n\n            let finalAlpha\n            if (opacity > 0) {\n                // 本来已经有一个透明度了\n                finalAlpha = opacity * (alpha / 256)\n            } else {\n                if (alpha < maxOpacity) {\n                    if (alpha < minOpacity) {\n                        finalAlpha = minOpacity\n                    } else {\n                        finalAlpha = alpha\n                    }\n                } else {\n                    finalAlpha = maxOpacity\n                }\n            }\n\n            imgData[i - 3] = palette[offset]\n            imgData[i - 2] = palette[offset + 1]\n            imgData[i - 1] = palette[offset + 2]\n            // console.log('useGradientOpacity', useGradientOpacity)\n            // console.log('finalAlpha', finalAlpha)\n            imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha\n        }\n\n        // img.data = imgData\n        this.ctx.putImageData(img, x, y)\n\n        this._renderBoundaries = [1000, 1000, 0, 0]\n    },\n    getValueAt: function(point) {\n        let value\n        const shadowCtx = this.shadowCtx\n        const img = shadowCtx.getImageData(point.x, point.y, 1, 1)\n        const data = img.data[3]\n        const max = this._max\n        const min = this._min\n\n        value = (Math.abs(max - min) * (data / 255)) >> 0\n\n        return value\n    },\n    getDataURL: function() {\n        return this.canvas.toDataURL()\n    },\n    getCanvas: function() {\n        return this.canvas\n    },\n}\n\nexport default Canvas2dRenderer\n","'use strict'\n\nimport HeatmapConfig from './config'\nimport Canvas2dRenderer from './canvas2d'\n\nconst Renderer = HeatmapConfig['defaultRenderer'] === 'canvas2d' ? Canvas2dRenderer : false\n\nexport default Renderer\n","'use strict'\n\nimport HeatmapConfig from './config'\n\nconst Store = function Store(config) {\n    this._coordinator = {}\n    this._data = []\n    this._total = 0\n    this._radi = []\n    this._min = 10\n    this._max = 1\n    this._xField = config['xField'] || config.defaultXField\n    this._yField = config['yField'] || config.defaultYField\n    this._valueField = config['valueField'] || config.defaultValueField\n\n    if (config['radius']) {\n        this._cfgRadius = config['radius']\n    }\n}\n\nconst defaultRadius = HeatmapConfig.defaultRadius\n\nStore.prototype = {\n    // when forceRender = false -> called from setData, omits renderall event\n    _organiseData: function(dataPoint, forceRender) {\n        const x = dataPoint[this._xField]\n        const y = dataPoint[this._yField]\n        const radi = this._radi\n        const store = this._data\n        const max = this._max\n        const min = this._min\n        const value = dataPoint[this._valueField] || 1\n        const radius = dataPoint.radius || this._cfgRadius || defaultRadius\n\n        if (!store[x]) {\n            store[x] = []\n            radi[x] = []\n        }\n\n        if (!store[x][y]) {\n            store[x][y] = value\n            radi[x][y] = radius\n        } else {\n            store[x][y] += value\n        }\n        const storedVal = store[x][y]\n\n        this._total += storedVal\n\n        if (storedVal > max) {\n            if (!forceRender) {\n                this._max = storedVal\n            } else {\n                this.setDataMax(storedVal)\n            }\n            return false\n        } else if (storedVal < min) {\n            if (!forceRender) {\n                this._min = storedVal\n            } else {\n                this.setDataMin(storedVal)\n            }\n            return false\n        } else {\n            return {\n                x: x,\n                y: y,\n                value: value,\n                radius: radius,\n                min: min,\n                max: max,\n            }\n        }\n    },\n    _unOrganizeData: function() {\n        const unorganizedData = []\n        const data = this._data\n        const radi = this._radi\n\n        for (const x in data) {\n            for (const y in data[x]) {\n                unorganizedData.push({\n                    x: x,\n                    y: y,\n                    radius: radi[x][y],\n                    value: data[x][y],\n                })\n            }\n        }\n        return {\n            min: this._min,\n            max: this._max,\n            data: unorganizedData,\n        }\n    },\n    _onExtremaChange: function() {\n        this._coordinator.emit('extremachange', {\n            min: this._min,\n            max: this._max,\n        })\n    },\n    addData: function() {\n        if (arguments[0].length > 0) {\n            const dataArr = arguments[0]\n            let dataLen = dataArr.length\n            while (dataLen--) {\n                // eslint-disable-next-line no-useless-call\n                this.addData.call(this, dataArr[dataLen])\n            }\n        } else {\n            // add to store\n            const organisedEntry = this._organiseData(arguments[0], true)\n            if (organisedEntry) {\n                // if it's the first datapoint initialize the extremas with it\n                if (this._data.length === 0) {\n                    this._min = this._max = organisedEntry.value\n                }\n                this._coordinator.emit('renderpartial', {\n                    min: this._min,\n                    max: this._max,\n                    data: [organisedEntry],\n                })\n            }\n        }\n        return this\n    },\n    getExtremaData: function() {\n        return {\n            max: this._max,\n            min: this._min,\n            total: this._total,\n        }\n    },\n    setData: function(obj) {\n        const { data, max, min } = obj\n        const dataPoints = data\n        const pointsLen = dataPoints.length\n\n        // reset data arrays\n        this._data = []\n        this._radi = []\n\n        for (let i = 0; i < pointsLen; i++) {\n            this._organiseData(dataPoints[i], false)\n        }\n\n        if (max || min) {\n            this._max = max\n            this._min = min || 0\n        }\n\n        this._onExtremaChange()\n        this._coordinator.emit('renderall', this._getInternalData())\n        return this\n    },\n    setCoordinator: function(coordinator) {\n        this._coordinator = coordinator\n    },\n    _getInternalData: function() {\n        return {\n            max: this._max,\n            min: this._min,\n            data: this._data,\n            radi: this._radi,\n        }\n    },\n    getData: function() {\n        return this._unOrganizeData()\n    },\n}\n\nexport default Store\n","'use strict'\n\nimport HeatmapConfig from './config'\nimport Renderer from './renderer'\nimport Store from './data'\n\n/**\n * 自定义监听器\n * on: 监听\n * emit: 触发事件\n */\nfunction Coordinator() {\n    this.cStore = {}\n}\n\nCoordinator.prototype = {\n    on: function(evtName, callback, scope) {\n        const cStore = this.cStore\n\n        if (!cStore[evtName]) {\n            cStore[evtName] = []\n        }\n        cStore[evtName].push(function(data) {\n            return callback.call(scope, data)\n        })\n    },\n    emit: function(evtName, data) {\n        const cStore = this.cStore\n        if (cStore[evtName]) {\n            const len = cStore[evtName].length\n            for (let i = 0; i < len; i++) {\n                const callback = cStore[evtName][i]\n                callback(data)\n            }\n        }\n    },\n}\n\nconst _connect = function(scope) {\n    const renderer = scope._renderer\n    const coordinator = scope._coordinator\n    const store = scope._store\n\n    // 监听渲染部分\n    coordinator.on('renderpartial', renderer.renderPartial, renderer)\n    // 监听渲染全部\n    coordinator.on('renderall', renderer.renderAll, renderer)\n\n    // 监听min, max是否发生变化。\n    // 可以在set config设置回调。\n    coordinator.on('extremachange', function(data) {\n        scope._config.onExtremaChange &&\n            scope._config.onExtremaChange({\n                min: data.min,\n                max: data.max,\n                gradient: scope._config['gradient'] || scope._config['defaultGradient'],\n            })\n    })\n\n    store.setCoordinator(coordinator)\n}\n\nfunction Heatmap(config = {}) {\n    config = this._config = Object.assign(HeatmapConfig, config)\n    this._coordinator = new Coordinator()\n\n    /**\n     * 用户自定义的插件, 使用前需要注册插件\n     * 插件需要自带renderer和store属性\n     */\n    if (config['plugin']) {\n        const pluginToLoad = config['plugin']\n        if (!HeatmapConfig.plugins[pluginToLoad]) {\n            throw new Error(\"Plugin '\" + pluginToLoad + \"' not found. Maybe it was not registered.\")\n        } else {\n            const plugin = HeatmapConfig.plugins[pluginToLoad]\n            // set plugin renderer and store\n            // eslint-disable-next-line new-cap\n            this._renderer = new plugin.renderer(config)\n            // eslint-disable-next-line new-cap\n            this._store = new plugin.store(config)\n        }\n    } else {\n        // init canvas2d\n        // container appendChild canvas\n        // 初始化调色板\n        // get到canvas的属性/样式\n        this._renderer = new Renderer(config)\n\n        // init store\n        this._store = new Store(config)\n    }\n    _connect(this)\n}\n\n// @TODO:\n// add API documentation\nHeatmap.prototype = {\n    addData: function() {\n        this._store.addData.apply(this._store, arguments)\n        return this\n    },\n    removeData: function() {\n        this._store.removeData && this._store.removeData.apply(this._store, arguments)\n        return this\n    },\n    setData: function() {\n        this._store.setData.apply(this._store, arguments)\n        return this\n    },\n    setDataMax: function() {\n        this._store.setDataMax.apply(this._store, arguments)\n        return this\n    },\n    setDataMin: function() {\n        this._store.setDataMin.apply(this._store, arguments)\n        return this\n    },\n    configure: function(config) {\n        this._config = Object.assign(this._config, config)\n        this._renderer.updateConfig(this._config)\n        this._coordinator.emit('renderall', this._store._getInternalData())\n        return this\n    },\n    repaint: function() {\n        this._coordinator.emit('renderall', this._store._getInternalData())\n        return this\n    },\n    getData: function() {\n        return this._store.getData()\n    },\n    getDataURL: function() {\n        return this._renderer.getDataURL()\n    },\n    getCanvas: function() {\n        return this._renderer.getCanvas()\n    },\n    getGradient: function() {\n        return this._config['gradient'] || this._config['defaultGradient']\n    },\n    getExtremaData: function() {\n        return this._store.getExtremaData()\n    },\n    getValueAt: function(point) {\n        if (this._store.getValueAt) {\n            return this._store.getValueAt(point)\n        } else if (this._renderer.getValueAt) {\n            return this._renderer.getValueAt(point)\n        } else {\n            return null\n        }\n    },\n}\n\n// core\nconst heatmapFactory = {\n    create: function(config) {\n        return new Heatmap(config)\n    },\n    register: function(pluginKey, plugin) {\n        HeatmapConfig.plugins[pluginKey] = plugin\n    },\n}\n\nexport default heatmapFactory\n","import heatmap from './heatmap/core'\n\nexport function drawImageScaled({ img, layers = [], layer, canvas, options = {} }) {\n    const ctx = canvas.getContext('2d')\n\n    if (layers.length === 0 && layer) {\n        layers = [layer]\n    }\n\n    const canvasWidth = Math.max(canvas.offsetWidth, canvas.width)\n    const canvasHeight = Math.max(canvas.offsetHeight, canvas.height)\n    let actualSize = {\n        width: canvasWidth,\n        height: canvasHeight,\n    }\n    if (img) {\n        let ratio\n        const hRatio = canvasWidth / img.width\n        const vRatio = canvasHeight / img.height\n        if (options.fixedWidth) {\n            ratio = hRatio\n        } else if (options.fixedHeight) {\n            ratio = vRatio\n        } else {\n            ratio = Math.min(hRatio, vRatio)\n        }\n        actualSize = {\n            width: img.width * ratio,\n            height: img.height * ratio,\n        }\n    }\n\n    canvas.width = actualSize.width\n    canvas.height = actualSize.height\n\n    layers.map((la, index) => {\n        if (!la) {\n            return\n        }\n\n        ctx.drawImage(la, 0, 0, la.width, la.height, 0, 0, actualSize.width, actualSize.height)\n    })\n}\n\n/* 画渐变标尺 */\nfunction drawGradient({ gradientCfg, extrema, width, height, type = 'maxPercent' }) {\n    let canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    const ctx = canvas.getContext('2d')\n\n    const padding = width * 0.02\n    const [paddingL, paddingT, paddingR, paddingB] = [padding, padding, padding, padding / 4]\n    const graW = width * 0.13\n    const graH = height * 0.008\n    const fontSize = width * 0.016\n    const bgW = graW + paddingL + paddingR\n    const bgH = graH + paddingT + paddingB\n    ctx.fillStyle = 'rgba(0,0,0, 0.5)'\n\n    // 黑色半透明底色\n    ctx.fillRect(width - bgW, height - bgH, bgW, bgH)\n\n    // 渐变\n    const x0 = width - paddingR - graW\n    const y0 = height - paddingB - graH\n    const x1 = width - paddingR\n    const y1 = height - paddingB\n\n    const gradient = ctx.createLinearGradient(x0, y0, x1, y1)\n    for (let key in gradientCfg) {\n        gradient.addColorStop(key, gradientCfg[key])\n    }\n    ctx.fillStyle = gradient\n    ctx.fillRect(x0, y0, graW, graH)\n\n    // 极值\n    ctx.font = `normal ${fontSize}px Microsoft YaHei`\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'\n    const textBottom = height - graH - paddingB * 1.5\n    const { min = 0, max = 0, total } = extrema\n\n    let unit = ''\n    let fix = 0\n    let minValue = min\n    let middleValue = (min + max) / 2\n    let maxValue = max\n\n    if (total !== 0 && type === 'maxPercent') {\n        unit = '%'\n        fix = 1\n        minValue = (min / total) * 100\n        middleValue = ((min + max) / 2 / total) * 100\n        maxValue = (max / total) * 100\n    }\n\n    const fillTexts = [\n        {\n            text: minValue.toFixed(fix) + unit,\n            x: width - bgW + paddingB,\n            y: textBottom,\n        },\n        {\n            text: middleValue.toFixed(fix) + unit,\n            x: width - bgW + graW / 2,\n            y: textBottom,\n        },\n        {\n            text: maxValue.toFixed(fix) + unit,\n            x: width - paddingR * 2,\n            y: textBottom,\n        },\n    ]\n\n    // eslint-disable-next-line array-callback-return\n    fillTexts.map((item) => {\n        const { text, x, y } = item\n        ctx.fillText(text, x, y)\n    })\n\n    return canvas\n}\n\nexport function getImageInfo(path) {\n    return new Promise((resolve, reject) => {\n        const img = new Image()\n        img.onload = () => {\n            resolve(img)\n        }\n        img.onerror = (e) => {\n            reject(e)\n        }\n        img.src = path\n    })\n}\n\nexport function drawHeatmap({\n    points,\n    directionPoints,\n    path,\n    canvas,\n    type = 'maxPercent',\n    accuracy = 33,\n    radius,\n    options = {},\n}) {\n    return getImageInfo(path)\n        .then((img) => {\n            const { width, height } = img\n            radius = radius || Math.max(width, height) / accuracy\n            points = points.map(({ x, y, value }) => {\n                x = x * width\n                y = y * height\n                return { x, y, value }\n            })\n\n            let obj = {}\n            obj.data = points\n\n            const heatmapInstance = heatmap.create({\n                opacity: 0.6,\n                width,\n                height,\n                radius,\n            })\n\n            heatmapInstance.setData(obj)\n            return { img, heatmapInstance }\n        })\n        .then(({ img, heatmapInstance }) => {\n            const { width, height } = img\n            const gradientCfg = heatmapInstance.getGradient()\n            const extrema = heatmapInstance.getExtremaData()\n            const gradientCanvas = drawGradient({\n                gradientCfg,\n                extrema,\n                width,\n                height,\n                type,\n            })\n\n            let directionCanvas = null\n\n            if (directionPoints && directionPoints.length > 0) {\n                directionCanvas = drawDirection({\n                    points: directionPoints,\n                    width,\n                    height,\n                    accuracy: 6,\n                    filtration: 0.03,\n                })\n            }\n\n            const layers = [img, heatmapInstance.getCanvas(), directionCanvas, gradientCanvas]\n            drawImageScaled({ img, layers, canvas, options })\n            return { img, heatmap: heatmapInstance }\n        })\n}\n// 坐标为文本基准线中点\nexport function drawText(\n    canvas,\n    text = '',\n    centerPoint = [0, 0],\n    {\n        fontSize = 20,\n        fontFamily = 'PingFangSC-Regular',\n        color = '#000',\n        usePercent = true,\n        border,\n    } = {}\n) {\n    const { clientWidth: w, clientHeight: h } = canvas\n    const [x, y] = usePercent ? getAbsPoint(centerPoint, w, h) : centerPoint\n    const ctx = canvas.getContext('2d')\n    if (border) {\n        const { width } = ctx.measureText(text)\n        drawTextBorder(\n            canvas,\n            [x, y],\n            Object.assign({}, border, { textWidth: width, fontSize, usePercent: false })\n        )\n    }\n    ctx.font = `${fontSize}px ${fontFamily}`\n    ctx.textAlign = 'center'\n    ctx.fillStyle = color\n    ctx.fillText(text, x, y)\n}\n\nexport function drawTextBorder(\n    canvas,\n    textBaseLineCenterPoint = [0, 0],\n    { padding = 0, radius, textWidth, width, color, fontSize, backgroundColor, usePercent }\n) {\n    const [x, y] = textBaseLineCenterPoint\n    let paddingL, paddingT\n    if (typeof padding === 'number') {\n        paddingL = paddingT = padding\n    } else if (Array.isArray(padding)) {\n        paddingT = padding[0]\n        paddingL = padding[1]\n    }\n    const rectWidth = paddingL * 2 + textWidth\n    const rectHeight = paddingT * 2 + fontSize\n    const rectL = x - rectWidth / 2\n    const rectT = y - fontSize - paddingT\n    const leftTopPoint = [rectL, rectT]\n    if (radius) {\n        drawRoundRect(canvas, leftTopPoint, {\n            radius,\n            width: rectWidth,\n            height: rectHeight,\n            lineWidth: width || 1,\n            lineColor: color,\n            backgroundColor: backgroundColor,\n            usePercent: false,\n        })\n    } else {\n        drawRect(canvas, leftTopPoint, {\n            width: rectWidth,\n            height: rectHeight,\n            lineWidth: width || 1,\n            lineColor: color,\n            backgroundColor: backgroundColor,\n            usePercent: false,\n        })\n    }\n}\n\nexport function drawPolygon(\n    canvas,\n    points,\n    { color = 'red', usePercent = true, lineWidth, backgroundColor }\n) {\n    const { clientWidth: w, clientHeight: h } = canvas\n    const l = points.length\n    const ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    const startPoint = usePercent ? getAbsPoint(points[0], w, h) : points[0]\n    ctx.moveTo(...startPoint)\n    for (let i = 1; i < l; i++) {\n        const p = usePercent ? getAbsPoint(points[i], w, h) : points[i]\n        ctx.lineTo(...p)\n    }\n    ctx.lineTo(...startPoint)\n    if (lineWidth) {\n        ctx.lineWidth = lineWidth\n        ctx.strokeStyle = color\n        ctx.stroke()\n    }\n    if (backgroundColor) {\n        ctx.fillStyle = backgroundColor\n        ctx.fill()\n    }\n}\n\nexport function drawRoundRect(\n    canvas,\n    leftTopPoint,\n    {\n        width,\n        height,\n        radius = 4,\n        lineWidth,\n        lineColor = 'red',\n        backgroundColor,\n        usePercent = true,\n    } = {}\n) {\n    const { clientWidth: w, clientHeight: h } = canvas\n    const ctx = canvas.getContext('2d')\n    const [x, y] = usePercent ? getAbsPoint(leftTopPoint, w, h) : leftTopPoint\n    ctx.beginPath()\n    ctx.moveTo(x, y)\n    ctx.lineTo(x + width, y)\n    ctx.arc(x + width, y + radius, radius, -0.5 * Math.PI, 0)\n    ctx.lineTo(x + width + radius, y + radius + height)\n    ctx.arc(x + width, y + height + radius, radius, 0, 0.5 * Math.PI)\n    ctx.lineTo(x, y + height + 2 * radius)\n    ctx.arc(x, y + radius + height, radius, 0.5 * Math.PI, 1 * Math.PI)\n    ctx.lineTo(x - radius, y + radius)\n    ctx.arc(x, y + radius, radius, 1 * Math.PI, 1.5 * Math.PI)\n    if (backgroundColor) {\n        ctx.fillStyle = backgroundColor\n        ctx.fill()\n    }\n    if (lineWidth) {\n        ctx.lineWidth = lineWidth\n        ctx.strokeStyle = lineColor\n        ctx.stroke()\n    }\n}\n\nexport function drawRect(\n    canvas,\n    leftTopPoint,\n    { width, height, lineWidth, lineColor = 'red', backgroundColor, usePercent = true }\n) {\n    const { clientWidth, clientHeight } = canvas\n    const ctx = canvas.getContext('2d')\n    const [x, y] = usePercent ? getAbsPoint(leftTopPoint, clientWidth, clientHeight) : leftTopPoint\n    const w = usePercent ? width * clientWidth : width\n    const h = usePercent ? height * clientHeight : height\n\n    if (backgroundColor) {\n        ctx.fillStyle = backgroundColor\n        ctx.fillRect(x, y, w, h)\n    }\n    if (lineWidth) {\n        ctx.strokeStyle = lineColor\n        ctx.lineWidth = lineWidth\n        ctx.strokeRect(x, y, w, h)\n    }\n}\n\nfunction getAbsPoint(point, w, h) {\n    return [w * point[0], h * point[1]]\n}\n\nfunction getPointsTotalAndMax(points) {\n    let total = 0\n    let maxDirectionValue = 0\n    let maxValue = 0\n    points.map(function(point) {\n        // console.log(point[0]*w, point[1]*h)\n        let isPointArray = Array.isArray(point),\n            value = isPointArray ? 1 : point.value\n        total += value\n\n        maxDirectionValue = point.max > maxDirectionValue ? point.max : maxDirectionValue\n        maxValue = point.value > maxValue ? point.value : maxValue\n    })\n    return { total, maxDirectionValue, maxValue }\n}\n\nfunction canvasArrow(ctx, fromx, fromy, tox, toy, lineWidth) {\n    const canvasGradient = ctx.createLinearGradient(fromx, fromy, tox, toy)\n    canvasGradient.addColorStop(0, 'rgba(255, 239, 120, 0)')\n    canvasGradient.addColorStop(0.5, 'rgba(255, 239, 120, 1)')\n    //canvasGradient.addColorStop(1, \"rgba(255, 239, 120, 1)\")\n    ctx.strokeStyle = canvasGradient\n\n    const headlen = lineWidth, // length of head in pixels\n        angle = Math.atan2(toy - fromy, tox - fromx)\n\n    ctx.moveTo(fromx, fromy)\n    ctx.lineTo(tox, toy)\n    ctx.moveTo(tox, toy)\n    ctx.lineTo(\n        tox - headlen * Math.cos(angle - Math.PI / 7),\n        toy - headlen * Math.sin(angle - Math.PI / 7)\n    )\n\n    //path from the side point of the arrow, to the other side point\n    ctx.lineTo(\n        tox - headlen * Math.cos(angle + Math.PI / 7),\n        toy - headlen * Math.sin(angle + Math.PI / 7)\n    )\n\n    //path from the side point back to the tip of the arrow, and then again to the opposite side point\n    ctx.lineTo(tox, toy)\n    ctx.lineTo(\n        tox - headlen * Math.cos(angle - Math.PI / 7),\n        toy - headlen * Math.sin(angle - Math.PI / 7)\n    )\n}\n\nexport function drawDirection({ points, width, height, accuracy = 6, filtration = 0.03 }) {\n    let canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    const ctx = canvas.getContext('2d')\n\n    const { maxValue } = getPointsTotalAndMax(points)\n\n    const minImgLength = Math.min(width, height)\n\n    const maxLinelength = Math.round(minImgLength / accuracy) / 2\n    const lineWidth = maxLinelength * 0.06\n    ctx.lineWidth = lineWidth\n\n    points.map((point) => {\n        // value: 一个区域的总人数\n        const { direction, x, y, value, max } = point\n        ctx.beginPath()\n\n        // 大于最大值的某个范围才画轨迹线\n        if (value / maxValue > filtration) {\n            direction.map((item) => {\n                ctx.beginPath()\n\n                let fromx = Math.round(width * x)\n                let fromy = Math.round(height * y)\n\n                const { label, count } = item\n\n                // 预留顶点坐标周围的空白\n                const offset = 0\n\n                let tox = 0\n                let toy = 0\n\n                const lineLength = maxLinelength * (count / max)\n\n                // 后方\n                if (label === 0) {\n                    tox = fromx\n                    toy = fromy + offset + lineLength\n                    fromy = fromy + offset\n                }\n                // 前方\n                if (label === 1) {\n                    tox = fromx\n                    toy = fromy - offset - lineLength\n                    fromy = fromy - offset\n                }\n                // 左方\n                if (label === 2) {\n                    tox = fromx - offset - lineLength\n                    toy = fromy\n                    fromx = fromx - offset\n                }\n                // 右方\n                if (label === 3) {\n                    tox = fromx + offset + lineLength\n                    toy = fromy\n                    fromx = fromx + offset\n                }\n\n                // 左后方\n                if (label === 4) {\n                    const pow2 = Math.pow(lineLength, 2)\n                    const lengthXY = Math.pow(pow2 / 2, 0.5)\n                    tox = fromx - offset - lengthXY\n                    toy = fromy + offset + lengthXY\n                    fromx = fromx - offset\n                    fromy = fromy + offset\n                }\n                // 左前方\n                if (label === 5) {\n                    const pow2 = Math.pow(lineLength, 2)\n                    const lengthXY = Math.pow(pow2 / 2, 0.5)\n                    tox = fromx - offset - lengthXY\n                    toy = fromy - offset - lengthXY\n                    fromx = fromx - offset\n                    fromy = fromy - offset\n                }\n                // 右后方\n                if (label === 6) {\n                    const pow2 = Math.pow(lineLength, 2)\n                    const lengthXY = Math.pow(pow2 / 2, 0.5)\n                    tox = fromx + offset + lengthXY\n                    toy = fromy + offset + lengthXY\n                    fromx = fromx + offset\n                    fromy = fromy + offset\n                }\n                // 右前方\n                if (label === 7) {\n                    const pow2 = Math.pow(lineLength, 2)\n                    const lengthXY = Math.pow(pow2 / 2, 0.5)\n                    tox = fromx + offset + lengthXY\n                    toy = fromy - offset - lengthXY\n                    fromx = fromx + offset\n                    fromy = fromy - offset\n                }\n\n                if (tox !== 0 && toy !== 0) {\n                    canvasArrow(ctx, fromx, fromy, tox, toy, lineWidth)\n                }\n                ctx.stroke()\n            })\n        }\n    })\n    return canvas\n}\n\nfunction getExtremeValueForTrack(tracks) {\n    let maxCount = 0\n    let minCount = 0\n    tracks.map((item, i) => {\n        const { count } = item\n\n        maxCount = Math.max(count, maxCount)\n        if (i === 0) {\n            minCount = count\n        } else {\n            minCount = Math.min(count, minCount)\n        }\n    })\n    return { minCount, maxCount }\n}\n\nfunction canvasArrowForTrack(ctx, fromx, fromy, tox, toy, maxLineWidth) {\n    const headlen = maxLineWidth * 0.2\n    const angle = Math.atan2(toy - fromy, tox - fromx)\n    const num = 10\n\n    ctx.moveTo(fromx, fromy)\n    ctx.lineTo(tox, toy)\n    ctx.moveTo(tox, toy)\n    ctx.lineTo(\n        tox - headlen * Math.cos(angle - Math.PI / num),\n        toy - headlen * Math.sin(angle - Math.PI / num)\n    )\n\n    //path from the side point of the arrow, to the other side point\n    ctx.lineTo(\n        tox - headlen * Math.cos(angle + Math.PI / num),\n        toy - headlen * Math.sin(angle + Math.PI / num)\n    )\n\n    //path from the side point back to the tip of the arrow, and then again to the opposite side point\n    ctx.lineTo(tox, toy)\n    ctx.lineTo(\n        tox - headlen * Math.cos(angle - Math.PI / num),\n        toy - headlen * Math.sin(angle - Math.PI / num)\n    )\n    ctx.fill()\n}\n\nfunction getTrackCanvas({ width, height, tracks }) {\n    let canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    const ctx = canvas.getContext('2d')\n\n    const { minCount, maxCount } = getExtremeValueForTrack(tracks)\n    const diff = maxCount - minCount\n\n    const color = 'rgba(255, 239, 120, 0.5)'\n    ctx.strokeStyle = color\n    ctx.fillStyle = color\n\n    const minImgLength = Math.min(width, height)\n    const maxLineWidth = minImgLength * 0.015\n\n    tracks.map((linePoint) => {\n        ctx.beginPath()\n\n        const count = linePoint.count\n        const lineWidth = ((count - minCount) / diff) * maxLineWidth + 1\n\n        ctx.lineWidth = lineWidth\n        const points = linePoint.points || linePoint.walkPoints || []\n\n        points.map((point, index) => {\n            if (index >= 1) {\n                const fromx = Math.round(width * points[index - 1].x)\n                const fromy = Math.round(height * points[index - 1].y)\n\n                const tox = Math.round(width * point.x)\n                const toy = Math.round(height * point.y)\n                canvasArrowForTrack(ctx, fromx, fromy, tox, toy, maxLineWidth)\n            }\n        })\n        ctx.stroke()\n    })\n    return canvas\n}\n\nexport function drawTrack({ path, tracks, canvas }) {\n    return getImageInfo(path).then((img) => {\n        const { width, height } = img\n\n        const trackCanvas = getTrackCanvas({ width, height, tracks })\n\n        const layers = [img, trackCanvas]\n\n        drawImageScaled({ img, layers, canvas })\n        return { img }\n    })\n}\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else {\n        window.location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel] ✨ Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel] 🚨  ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\">🚨</span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}